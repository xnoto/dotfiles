#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "requests",
#     "watchdog",
# ]
# ///
"""
agent-hub-daemon: Watch ~/.agent-hub/messages and inject into OpenCode sessions.

Features:
- Push notifications to OpenCode sessions
- Thread management (auto-create, track, resolve)
- Garbage collection (expire stale messages/threads)

Wake behavior (noReply: false):
- type="question" â†’ always wake
- type="task" + priority="urgent" â†’ always wake
- metadata.wake=true â†’ wake only if session is idle
- Otherwise â†’ noReply: true (no wake)

Thread lifecycle:
- Messages without threadId get one auto-assigned
- Threads tracked in ~/.agent-hub/threads/
- Thread resolved when owner sends type="completion" with "RESOLVED" in content
- Threads expire when all participants are stale (>1hr lastSeen)
- Messages expire after 1 hour regardless

Idle detection: session is idle if last message role is "assistant"
"""

import json
import logging
import os
import shutil
import time
import uuid
from pathlib import Path
from typing import Optional

import requests
from watchdog.events import FileSystemEventHandler, FileCreatedEvent
from watchdog.observers import Observer

# Configuration
AGENT_HUB_DIR = Path.home() / ".agent-hub"
MESSAGES_DIR = AGENT_HUB_DIR / "messages"
ARCHIVE_DIR = MESSAGES_DIR / "archive"
THREADS_DIR = AGENT_HUB_DIR / "threads"
AGENTS_DIR = AGENT_HUB_DIR / "agents"
OPENCODE_PORT = int(os.environ.get("OPENCODE_PORT", "4096"))
OPENCODE_URL = f"http://localhost:{OPENCODE_PORT}"
LOG_LEVEL = os.environ.get("AGENT_HUB_DAEMON_LOG_LEVEL", "INFO")

# Expiry settings
MESSAGE_TTL_SECONDS = 3600  # 1 hour
AGENT_STALE_SECONDS = 3600  # 1 hour
GC_INTERVAL_SECONDS = 60    # Run GC every 60 seconds

logging.basicConfig(
    level=getattr(logging, LOG_LEVEL),
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
log = logging.getLogger(__name__)


# =============================================================================
# Agent Management
# =============================================================================

def load_agents() -> dict[str, dict]:
    """Load all registered agents, keyed by agent ID."""
    agents = {}
    if not AGENTS_DIR.exists():
        return agents
    for f in AGENTS_DIR.glob("*.json"):
        try:
            agent = json.loads(f.read_text())
            agents[agent["id"]] = agent
        except (json.JSONDecodeError, KeyError) as e:
            log.warning(f"Failed to load agent {f}: {e}")
    return agents


def is_agent_active(agent: dict) -> bool:
    """Check if agent has been seen within the stale threshold."""
    last_seen = agent.get("lastSeen", 0)
    age_seconds = (time.time() * 1000 - last_seen) / 1000
    return age_seconds < AGENT_STALE_SECONDS


# =============================================================================
# Thread Management
# =============================================================================

def load_thread(thread_id: str) -> Optional[dict]:
    """Load a thread by ID."""
    path = THREADS_DIR / f"{thread_id}.json"
    if not path.exists():
        return None
    try:
        return json.loads(path.read_text())
    except (json.JSONDecodeError, OSError) as e:
        log.warning(f"Failed to load thread {thread_id}: {e}")
        return None


def save_thread(thread: dict) -> None:
    """Save a thread."""
    THREADS_DIR.mkdir(parents=True, exist_ok=True)
    path = THREADS_DIR / f"{thread['id']}.json"
    path.write_text(json.dumps(thread, indent=2))


def create_thread(msg: dict) -> dict:
    """Create a new thread from a message."""
    thread_id = msg.get("threadId") or str(uuid.uuid4())[:12]
    now = int(time.time() * 1000)
    
    participants = {msg.get("from", "unknown")}
    to = msg.get("to", "")
    if to and to != "all":
        participants.add(to)
    
    thread = {
        "id": thread_id,
        "createdBy": msg.get("from", "unknown"),
        "createdAt": now,
        "participants": list(participants),
        "status": "open",
        "resolvedBy": None,
        "resolvedAt": None,
    }
    save_thread(thread)
    return thread


def update_thread_participants(thread: dict, msg: dict) -> None:
    """Add new participants to a thread."""
    participants = set(thread.get("participants", []))
    participants.add(msg.get("from", "unknown"))
    to = msg.get("to", "")
    if to and to != "all":
        participants.add(to)
    thread["participants"] = list(participants)
    save_thread(thread)


def resolve_thread(thread_id: str, resolved_by: str) -> None:
    """Mark a thread as resolved and archive its messages."""
    thread = load_thread(thread_id)
    if not thread:
        return
    
    thread["status"] = "resolved"
    thread["resolvedBy"] = resolved_by
    thread["resolvedAt"] = int(time.time() * 1000)
    save_thread(thread)
    
    # Archive all messages in this thread
    archive_thread_messages(thread_id)
    log.info(f"Thread {thread_id} resolved by {resolved_by}")


def archive_thread_messages(thread_id: str) -> None:
    """Move all messages in a thread to archive."""
    ARCHIVE_DIR.mkdir(parents=True, exist_ok=True)
    for msg_path in MESSAGES_DIR.glob("*.json"):
        try:
            msg = json.loads(msg_path.read_text())
            if msg.get("threadId") == thread_id:
                dest = ARCHIVE_DIR / msg_path.name
                shutil.move(str(msg_path), str(dest))
                log.debug(f"Archived message {msg_path.name} (thread resolved)")
        except (json.JSONDecodeError, OSError):
            continue


def ensure_thread_id(msg: dict, msg_path: Path) -> str:
    """Ensure message has a threadId, creating one if needed."""
    if msg.get("threadId"):
        thread_id = msg["threadId"]
        thread = load_thread(thread_id)
        if thread:
            update_thread_participants(thread, msg)
        else:
            create_thread(msg)
    else:
        # Auto-generate threadId
        thread = create_thread(msg)
        thread_id = thread["id"]
        msg["threadId"] = thread_id
        # Rewrite the message file with threadId
        msg_path.write_text(json.dumps(msg, indent=2))
        log.debug(f"Auto-assigned threadId {thread_id} to message {msg_path.name}")
    
    return msg.get("threadId", "")


def check_thread_resolution(msg: dict) -> bool:
    """Check if message resolves a thread. Returns True if resolved."""
    if msg.get("type") != "completion":
        return False
    
    content = msg.get("content", "").upper()
    if "RESOLVED" not in content:
        return False
    
    thread_id = msg.get("threadId")
    if not thread_id:
        return False
    
    thread = load_thread(thread_id)
    if not thread:
        return False
    
    # Check if sender is the thread owner (creator) or it's a broadcast thread
    sender = msg.get("from", "")
    is_owner = thread.get("createdBy") == sender
    is_broadcast = msg.get("to") == "all" or thread.get("createdBy") == "all"
    
    if is_owner or is_broadcast:
        resolve_thread(thread_id, sender)
        return True
    
    return False


# =============================================================================
# Garbage Collection
# =============================================================================

def run_gc(agents: dict[str, dict]) -> None:
    """Run garbage collection on messages and threads."""
    now_ms = int(time.time() * 1000)
    ARCHIVE_DIR.mkdir(parents=True, exist_ok=True)
    
    # 1. Archive expired messages (>1hr old)
    for msg_path in MESSAGES_DIR.glob("*.json"):
        try:
            msg = json.loads(msg_path.read_text())
            timestamp = msg.get("timestamp", 0)
            age_ms = now_ms - timestamp
            if age_ms > MESSAGE_TTL_SECONDS * 1000:
                dest = ARCHIVE_DIR / msg_path.name
                shutil.move(str(msg_path), str(dest))
                log.debug(f"Archived expired message {msg_path.name} (age: {age_ms/1000:.0f}s)")
        except (json.JSONDecodeError, OSError):
            continue
    
    # 2. Check threads with all stale participants
    if not THREADS_DIR.exists():
        return
    
    for thread_path in THREADS_DIR.glob("*.json"):
        try:
            thread = json.loads(thread_path.read_text())
            if thread.get("status") == "resolved":
                continue
            
            participants = thread.get("participants", [])
            all_stale = True
            for participant_id in participants:
                agent = agents.get(participant_id)
                if agent and is_agent_active(agent):
                    all_stale = False
                    break
            
            if all_stale and participants:
                log.info(f"Thread {thread['id']} expired (all participants stale)")
                thread["status"] = "expired"
                thread["resolvedAt"] = now_ms
                thread_path.write_text(json.dumps(thread, indent=2))
                archive_thread_messages(thread["id"])
        except (json.JSONDecodeError, OSError):
            continue


# =============================================================================
# OpenCode Integration
# =============================================================================

def get_sessions() -> list[dict]:
    """Fetch active OpenCode sessions."""
    try:
        resp = requests.get(f"{OPENCODE_URL}/session", timeout=5)
        resp.raise_for_status()
        return resp.json()
    except requests.RequestException as e:
        log.error(f"Failed to fetch sessions: {e}")
        return []


def find_session_for_agent(agent: dict, sessions: list[dict]) -> Optional[dict]:
    """Match agent to session by projectPath == directory."""
    agent_path = agent.get("projectPath", "")
    for session in sessions:
        if session.get("directory") == agent_path:
            return session
    return None


def is_session_idle(session_id: str) -> bool:
    """Check if session is idle (last message is from assistant)."""
    try:
        resp = requests.get(
            f"{OPENCODE_URL}/session/{session_id}/message",
            timeout=5,
        )
        resp.raise_for_status()
        messages = resp.json()
        if not messages:
            return True  # Empty session = idle
        last_msg = messages[-1]
        role = last_msg.get("info", {}).get("role", "")
        return role == "assistant"
    except requests.RequestException as e:
        log.warning(f"Failed to check session idle status: {e}")
        return False  # Assume busy if we can't tell


def should_wake(msg: dict, session_id: str) -> bool:
    """Determine if message should wake the agent (noReply: false)."""
    msg_type = msg.get("type", "")
    priority = msg.get("priority", "normal")
    metadata = msg.get("metadata", {})

    # Questions always wake
    if msg_type == "question":
        log.debug("Wake: message is a question")
        return True

    # Urgent tasks always wake
    if msg_type == "task" and priority == "urgent":
        log.debug("Wake: urgent task")
        return True

    # Explicit wake request - only if idle
    if metadata.get("wake"):
        idle = is_session_idle(session_id)
        log.debug(f"Wake requested, session idle={idle}")
        return idle

    return False


def inject_message(session_id: str, text: str, wake: bool = False) -> bool:
    """Inject message into OpenCode session."""
    payload = {
        "parts": [{"type": "text", "text": text}],
        "noReply": not wake,
    }
    try:
        resp = requests.post(
            f"{OPENCODE_URL}/session/{session_id}/message",
            json=payload,
            timeout=10,
        )
        if resp.status_code == 200:
            wake_str = "with wake" if wake else "silent"
            log.info(f"Injected message ({wake_str}) into session {session_id[:20]}...")
            return True
        else:
            log.error(f"Injection failed: {resp.status_code} {resp.text}")
            return False
    except requests.RequestException as e:
        log.error(f"Injection request failed: {e}")
        return False


def format_notification(msg: dict) -> str:
    """Format agent-hub message as structured notification block."""
    from_agent = msg.get("from", "unknown")
    msg_type = msg.get("type", "message")
    content = msg.get("content", "")
    priority = msg.get("priority", "normal")
    thread_id = msg.get("threadId", "")

    # Type icons
    type_icons = {
        "question": "â“",
        "task": "ðŸ“‹",
        "context": "ðŸ“Ž",
        "completion": "âœ…",
        "error": "âŒ",
    }
    icon = type_icons.get(msg_type, "ðŸ’¬")

    # Priority markers
    priority_markers = {
        "urgent": "ðŸš¨ URGENT",
        "high": "âš ï¸ HIGH",
        "normal": "",
        "low": "ðŸ’¤ LOW",
    }
    priority_str = priority_markers.get(priority, "")

    # Build notification block
    lines = [
        "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        f"â”‚ {icon} AGENT HUB MESSAGE",
        "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        f"â”‚ FROM: {from_agent}",
        f"â”‚ TYPE: {msg_type}" + (f" {priority_str}" if priority_str else ""),
    ]
    if thread_id:
        lines.append(f"â”‚ THREAD: {thread_id}")
    lines.extend([
        "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        f"â”‚ {content}",
        "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
    ])

    # Add action required hint for questions/urgent tasks
    if msg_type == "question":
        lines.insert(-1, "â”‚")
        lines.insert(-1, "â”‚ âš¡ ACTION REQUIRED: Please respond to this question")
    elif msg_type == "task" and priority == "urgent":
        lines.insert(-1, "â”‚")
        lines.insert(-1, "â”‚ âš¡ ACTION REQUIRED: Urgent task needs attention")

    return "\n".join(lines)


# =============================================================================
# Message Processing
# =============================================================================

def process_message_file(path: Path, agents: dict[str, dict]) -> None:
    """Process a new message file and inject if applicable."""
    try:
        msg = json.loads(path.read_text())
    except (json.JSONDecodeError, OSError) as e:
        log.warning(f"Failed to read message {path}: {e}")
        return

    # Ensure message has a threadId
    ensure_thread_id(msg, path)
    
    # Check if this message resolves a thread
    if check_thread_resolution(msg):
        return  # Thread resolved, messages archived

    # Determine target agent(s)
    to = msg.get("to", "")
    if to == "all":
        target_agents = list(agents.values())
    elif to in agents:
        target_agents = [agents[to]]
    else:
        log.debug(f"Unknown target agent: {to}")
        return

    # Skip if already read
    if msg.get("read"):
        return

    sessions = get_sessions()
    if not sessions:
        log.debug("No active sessions")
        return

    notification = format_notification(msg)

    for agent in target_agents:
        # Don't notify sender
        if agent["id"] == msg.get("from"):
            continue

        session = find_session_for_agent(agent, sessions)
        if session:
            session_id = session["id"]
            wake = should_wake(msg, session_id)
            inject_message(session_id, notification, wake=wake)
        else:
            log.debug(f"No session found for agent {agent['id']}")


# =============================================================================
# Event Handler
# =============================================================================

class MessageHandler(FileSystemEventHandler):
    """Handle new message files."""

    def __init__(self):
        self.agents = load_agents()
        self._last_reload = time.time()
        self._last_gc = time.time()

    def reload_agents_if_needed(self) -> None:
        """Reload agents periodically."""
        if time.time() - self._last_reload > 60:
            self.agents = load_agents()
            self._last_reload = time.time()

    def run_gc_if_needed(self) -> None:
        """Run garbage collection periodically."""
        if time.time() - self._last_gc > GC_INTERVAL_SECONDS:
            self.reload_agents_if_needed()
            run_gc(self.agents)
            self._last_gc = time.time()

    def on_created(self, event: FileCreatedEvent) -> None:
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix != ".json":
            return
        # Ignore archive directory
        if "archive" in path.parts:
            return

        self.reload_agents_if_needed()

        log.debug(f"New message file: {path.name}")
        # Small delay to ensure file is fully written
        time.sleep(0.1)
        process_message_file(path, self.agents)


# =============================================================================
# Main
# =============================================================================

def main():
    # Ensure directories exist
    MESSAGES_DIR.mkdir(parents=True, exist_ok=True)
    ARCHIVE_DIR.mkdir(parents=True, exist_ok=True)
    THREADS_DIR.mkdir(parents=True, exist_ok=True)

    log.info(f"Watching {MESSAGES_DIR}")
    log.info(f"OpenCode API: {OPENCODE_URL}")
    log.info("Wake behavior: questions=always, urgent_tasks=always, wake_flag=if_idle")
    log.info(f"Message TTL: {MESSAGE_TTL_SECONDS}s, GC interval: {GC_INTERVAL_SECONDS}s")

    handler = MessageHandler()
    observer = Observer()
    observer.schedule(handler, str(MESSAGES_DIR), recursive=False)
    observer.start()

    try:
        while True:
            time.sleep(1)
            handler.run_gc_if_needed()
    except KeyboardInterrupt:
        log.info("Shutting down")
        observer.stop()
    observer.join()


if __name__ == "__main__":
    main()
