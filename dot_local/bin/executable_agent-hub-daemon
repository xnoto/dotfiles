#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "requests",
#     "watchdog",
# ]
# ///
"""
agent-hub-daemon: Watch ~/.agent-hub/messages and inject into OpenCode sessions.

Features:
- Hub server management (auto-starts headless OpenCode server on port 4096)
- Session polling to detect new agents and inject orientation
- Push notifications to OpenCode sessions (always wake, always expect response)
- Thread management (auto-create, track, resolve)
- Garbage collection (expire stale messages/threads)
- Self-contained response instructions in every injection

Hub server:
- Daemon auto-starts `opencode serve --port 4096` if not already running
- Single hub server provides HTTP API access to ALL OpenCode sessions
- Any `opencode` TUI instance creates sessions visible via hub API
- Daemon injects messages via POST /session/{id}/message

Wake behavior: ALL messages wake agents (noReply: false)
- Agents don't need hub protocol in their definitions
- Daemon injects full response instructions with each message
- Running daemon = opt-in to coordination

Session polling:
- Polls OpenCode /session endpoint periodically
- Matches sessions to registered agents by projectPath
- Injects orientation message on first match (instructs agent to sync)
- Tracks oriented sessions to avoid re-injection

Thread lifecycle:
- Messages without threadId get one auto-assigned
- Threads tracked in ~/.agent-hub/threads/
- Thread resolved when owner sends type="completion" with "RESOLVED" in content
- Threads expire when all participants are stale (>1hr lastSeen)
- Messages expire after 1 hour regardless
- Stale agents (>1hr lastSeen) are removed automatically
"""

import json
import logging
import os
import shutil
import signal
import subprocess
import time
import uuid
from pathlib import Path
from typing import Optional

import requests
from watchdog.events import FileSystemEventHandler, FileCreatedEvent
from watchdog.observers import Observer

# Configuration
AGENT_HUB_DIR = Path.home() / ".agent-hub"
MESSAGES_DIR = AGENT_HUB_DIR / "messages"
ARCHIVE_DIR = MESSAGES_DIR / "archive"
THREADS_DIR = AGENT_HUB_DIR / "threads"
AGENTS_DIR = AGENT_HUB_DIR / "agents"
OPENCODE_DATA_DIR = Path.home() / ".local/share/opencode"
OPENCODE_SESSIONS_DIR = OPENCODE_DATA_DIR / "storage/session/global"
OPENCODE_PORT = int(os.environ.get("OPENCODE_PORT", "4096"))
OPENCODE_URL = f"http://localhost:{OPENCODE_PORT}"
LOG_LEVEL = os.environ.get("AGENT_HUB_DAEMON_LOG_LEVEL", "INFO")

# Expiry settings
MESSAGE_TTL_SECONDS = 3600  # 1 hour
AGENT_STALE_SECONDS = 3600  # 1 hour
GC_INTERVAL_SECONDS = 60    # Run GC every 60 seconds

# Track sessions that have been oriented (session_id -> True)
ORIENTED_SESSIONS: set[str] = set()

# Hub server process (launched by daemon if needed)
HUB_SERVER_PROCESS: Optional[subprocess.Popen] = None

logging.basicConfig(
    level=getattr(logging, LOG_LEVEL),
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
log = logging.getLogger(__name__)


# =============================================================================
# Agent Management
# =============================================================================

def load_agents() -> dict[str, dict]:
    """Load all registered agents, keyed by agent ID."""
    agents = {}
    if not AGENTS_DIR.exists():
        return agents
    for f in AGENTS_DIR.glob("*.json"):
        try:
            agent = json.loads(f.read_text())
            agents[agent["id"]] = agent
        except (json.JSONDecodeError, KeyError) as e:
            log.warning(f"Failed to load agent {f}: {e}")
    return agents


def is_agent_active(agent: dict) -> bool:
    """Check if agent has been seen within the stale threshold."""
    last_seen = agent.get("lastSeen", 0)
    age_seconds = (time.time() * 1000 - last_seen) / 1000
    return age_seconds < AGENT_STALE_SECONDS


# =============================================================================
# Thread Management
# =============================================================================

def load_thread(thread_id: str) -> Optional[dict]:
    """Load a thread by ID."""
    path = THREADS_DIR / f"{thread_id}.json"
    if not path.exists():
        return None
    try:
        return json.loads(path.read_text())
    except (json.JSONDecodeError, OSError) as e:
        log.warning(f"Failed to load thread {thread_id}: {e}")
        return None


def save_thread(thread: dict) -> None:
    """Save a thread."""
    THREADS_DIR.mkdir(parents=True, exist_ok=True)
    path = THREADS_DIR / f"{thread['id']}.json"
    path.write_text(json.dumps(thread, indent=2))


def create_thread(msg: dict) -> dict:
    """Create a new thread from a message."""
    thread_id = msg.get("threadId") or str(uuid.uuid4())[:12]
    now = int(time.time() * 1000)

    participants = {msg.get("from", "unknown")}
    to = msg.get("to", "")
    if to and to != "all":
        participants.add(to)

    thread = {
        "id": thread_id,
        "createdBy": msg.get("from", "unknown"),
        "createdAt": now,
        "participants": list(participants),
        "status": "open",
        "resolvedBy": None,
        "resolvedAt": None,
    }
    save_thread(thread)
    return thread


def update_thread_participants(thread: dict, msg: dict) -> None:
    """Add new participants to a thread."""
    participants = set(thread.get("participants", []))
    participants.add(msg.get("from", "unknown"))
    to = msg.get("to", "")
    if to and to != "all":
        participants.add(to)
    thread["participants"] = list(participants)
    save_thread(thread)


def resolve_thread(thread_id: str, resolved_by: str) -> None:
    """Mark a thread as resolved and archive its messages."""
    thread = load_thread(thread_id)
    if not thread:
        return

    thread["status"] = "resolved"
    thread["resolvedBy"] = resolved_by
    thread["resolvedAt"] = int(time.time() * 1000)
    save_thread(thread)

    # Archive all messages in this thread
    archive_thread_messages(thread_id)
    log.info(f"Thread {thread_id} resolved by {resolved_by}")


def archive_thread_messages(thread_id: str) -> None:
    """Move all messages in a thread to archive."""
    ARCHIVE_DIR.mkdir(parents=True, exist_ok=True)
    for msg_path in MESSAGES_DIR.glob("*.json"):
        try:
            msg = json.loads(msg_path.read_text())
            if msg.get("threadId") == thread_id:
                dest = ARCHIVE_DIR / msg_path.name
                shutil.move(str(msg_path), str(dest))
                log.debug(f"Archived message {msg_path.name} (thread resolved)")
        except (json.JSONDecodeError, OSError):
            continue


def ensure_thread_id(msg: dict, msg_path: Path) -> str:
    """Ensure message has a threadId, creating one if needed."""
    if msg.get("threadId"):
        thread_id = msg["threadId"]
        thread = load_thread(thread_id)
        if thread:
            update_thread_participants(thread, msg)
        else:
            create_thread(msg)
    else:
        # Auto-generate threadId
        thread = create_thread(msg)
        thread_id = thread["id"]
        msg["threadId"] = thread_id
        # Rewrite the message file with threadId
        msg_path.write_text(json.dumps(msg, indent=2))
        log.debug(f"Auto-assigned threadId {thread_id} to message {msg_path.name}")

    return msg.get("threadId", "")


def check_thread_resolution(msg: dict) -> bool:
    """Check if message resolves a thread. Returns True if resolved."""
    if msg.get("type") != "completion":
        return False

    content = msg.get("content", "").upper()
    if "RESOLVED" not in content:
        return False

    thread_id = msg.get("threadId")
    if not thread_id:
        return False

    thread = load_thread(thread_id)
    if not thread:
        return False

    # Check if sender is the thread owner (creator) or it's a broadcast thread
    sender = msg.get("from", "")
    is_owner = thread.get("createdBy") == sender
    is_broadcast = msg.get("to") == "all" or thread.get("createdBy") == "all"

    if is_owner or is_broadcast:
        resolve_thread(thread_id, sender)
        return True

    return False


# =============================================================================
# Garbage Collection
# =============================================================================

def run_gc(agents: dict[str, dict]) -> None:
    """Run garbage collection on messages, threads, and stale agents."""
    now_ms = int(time.time() * 1000)
    ARCHIVE_DIR.mkdir(parents=True, exist_ok=True)

    # 1. Remove stale agents (>1hr since lastSeen)
    if AGENTS_DIR.exists():
        for agent_path in AGENTS_DIR.glob("*.json"):
            try:
                agent = json.loads(agent_path.read_text())
                last_seen = agent.get("lastSeen", 0)
                age_ms = now_ms - last_seen
                if age_ms > AGENT_STALE_SECONDS * 1000:
                    agent_id = agent.get("id", agent_path.stem)
                    agent_path.unlink()
                    # Remove from in-memory cache too
                    agents.pop(agent_id, None)
                    log.info(f"Removed stale agent {agent_id} (age: {age_ms/1000/60:.0f}m)")
            except (json.JSONDecodeError, OSError) as e:
                log.warning(f"Failed to check agent {agent_path}: {e}")
                continue

    # 2. Archive expired messages (>1hr old)
    for msg_path in MESSAGES_DIR.glob("*.json"):
        try:
            msg = json.loads(msg_path.read_text())
            timestamp = msg.get("timestamp", 0)
            age_ms = now_ms - timestamp
            if age_ms > MESSAGE_TTL_SECONDS * 1000:
                dest = ARCHIVE_DIR / msg_path.name
                shutil.move(str(msg_path), str(dest))
                log.debug(f"Archived expired message {msg_path.name} (age: {age_ms/1000:.0f}s)")
        except (json.JSONDecodeError, OSError):
            continue

    # 3. Check threads with all stale participants
    if not THREADS_DIR.exists():
        return

    for thread_path in THREADS_DIR.glob("*.json"):
        try:
            thread = json.loads(thread_path.read_text())
            if thread.get("status") == "resolved":
                continue

            participants = thread.get("participants", [])
            all_stale = True
            for participant_id in participants:
                agent = agents.get(participant_id)
                if agent and is_agent_active(agent):
                    all_stale = False
                    break

            if all_stale and participants:
                log.info(f"Thread {thread['id']} expired (all participants stale)")
                thread["status"] = "expired"
                thread["resolvedAt"] = now_ms
                thread_path.write_text(json.dumps(thread, indent=2))
                archive_thread_messages(thread["id"])
        except (json.JSONDecodeError, OSError):
            continue


# =============================================================================
# Hub Server Management
# =============================================================================

def is_hub_server_running() -> bool:
    """Check if OpenCode hub server is responding on the configured port."""
    try:
        resp = requests.get(f"{OPENCODE_URL}/session", timeout=2)
        return resp.status_code == 200
    except requests.RequestException:
        return False


def start_hub_server() -> Optional[subprocess.Popen]:
    """Launch OpenCode hub server in headless mode.
    
    The hub server provides HTTP API access to ALL OpenCode sessions,
    allowing the daemon to inject messages into any session.
    """
    global HUB_SERVER_PROCESS
    
    if is_hub_server_running():
        log.info(f"Hub server already running on port {OPENCODE_PORT}")
        return None
    
    log.info(f"Starting OpenCode hub server on port {OPENCODE_PORT}...")
    
    # Find opencode binary
    opencode_bin = shutil.which("opencode")
    if not opencode_bin:
        log.error("opencode binary not found in PATH")
        return None
    
    # Launch headless server
    try:
        # Redirect stdout/stderr to log files
        log_dir = Path.home() / ".local/share/agent-hub-daemon"
        log_dir.mkdir(parents=True, exist_ok=True)
        hub_stdout = open(log_dir / "hub-stdout.log", "a")
        hub_stderr = open(log_dir / "hub-stderr.log", "a")
        
        HUB_SERVER_PROCESS = subprocess.Popen(
            [opencode_bin, "serve", "--port", str(OPENCODE_PORT), "--print-logs"],
            stdout=hub_stdout,
            stderr=hub_stderr,
            start_new_session=True,  # Detach from terminal
        )
        
        # Wait for server to start
        for _ in range(30):  # 30 attempts, 0.5s each = 15s max
            time.sleep(0.5)
            if is_hub_server_running():
                log.info(f"Hub server started (PID {HUB_SERVER_PROCESS.pid})")
                return HUB_SERVER_PROCESS
        
        log.error("Hub server failed to start within timeout")
        HUB_SERVER_PROCESS.terminate()
        HUB_SERVER_PROCESS = None
        return None
        
    except Exception as e:
        log.error(f"Failed to start hub server: {e}")
        return None


def stop_hub_server() -> None:
    """Stop the hub server if we started it."""
    global HUB_SERVER_PROCESS
    
    if HUB_SERVER_PROCESS is not None:
        log.info(f"Stopping hub server (PID {HUB_SERVER_PROCESS.pid})...")
        try:
            HUB_SERVER_PROCESS.terminate()
            HUB_SERVER_PROCESS.wait(timeout=5)
        except subprocess.TimeoutExpired:
            log.warning("Hub server didn't stop gracefully, killing...")
            HUB_SERVER_PROCESS.kill()
        HUB_SERVER_PROCESS = None


# =============================================================================
# OpenCode Integration
# =============================================================================

def get_sessions() -> list[dict]:
    """Fetch active OpenCode sessions."""
    try:
        resp = requests.get(f"{OPENCODE_URL}/session", timeout=5)
        resp.raise_for_status()
        return resp.json()
    except requests.RequestException as e:
        log.error(f"Failed to fetch sessions: {e}")
        return []


def find_sessions_for_agent(agent: dict, sessions: list[dict]) -> list[dict]:
    """Match agent to ALL sessions by projectPath == directory.
    
    Returns all matching sessions to support multiple sessions in same project.
    """
    agent_path = agent.get("projectPath", "")
    return [s for s in sessions if s.get("directory") == agent_path]





def inject_message(session_id: str, text: str) -> bool:
    """Inject message into OpenCode session. Always wakes (noReply: false)."""
    payload = {
        "parts": [{"type": "text", "text": text}],
        "noReply": False,  # Always wake - daemon controls coordination
    }
    try:
        resp = requests.post(
            f"{OPENCODE_URL}/session/{session_id}/message",
            json=payload,
            timeout=10,
        )
        if resp.status_code == 200:
            log.info(f"Injected message into session {session_id[:8]}...")
            return True
        else:
            log.error(f"Injection failed: {resp.status_code} {resp.text}")
            return False
    except requests.RequestException as e:
        log.error(f"Injection request failed: {e}")
        return False


# =============================================================================
# Session Orientation
# =============================================================================

def load_opencode_session(path: Path) -> Optional[dict]:
    """Load an OpenCode session file."""
    try:
        return json.loads(path.read_text())
    except (json.JSONDecodeError, OSError) as e:
        log.warning(f"Failed to load session {path}: {e}")
        return None


def find_agent_for_directory(directory: str, agents: dict[str, dict]) -> Optional[dict]:
    """Find registered agent matching a directory/projectPath."""
    for agent in agents.values():
        if agent.get("projectPath") == directory:
            return agent
    return None


def format_orientation(agent: dict) -> str:
    """Format orientation message for a newly detected agent session."""
    agent_id = agent.get("id", "unknown")
    project_path = agent.get("projectPath", "unknown")
    
    lines = [
        "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "â”‚ ğŸ”— AGENT HUB - CONNECTED",
        "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        f"â”‚ You are registered as: {agent_id}",
        f"â”‚ Project: {project_path}",
        "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "â”‚ Check for pending messages and work:",
        f"â”‚   agent-hub_sync(agentId: \"{agent_id}\")",
        "â”‚",
        "â”‚ Review any pending items before proceeding.",
        "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
    ]
    return "\n".join(lines)


def get_active_session_ids() -> set[str]:
    """Get IDs of currently active OpenCode sessions from the API."""
    sessions = get_sessions()
    return {s.get("id", "") for s in sessions if s.get("id")}


def orient_session(session_id: str, agent: dict) -> bool:
    """Inject orientation message into a session."""
    if not session_id:
        return False
    
    if session_id in ORIENTED_SESSIONS:
        return False  # Already oriented
    
    orientation = format_orientation(agent)
    if inject_message(session_id, orientation):
        ORIENTED_SESSIONS.add(session_id)
        log.info(f"Oriented session {session_id[:8]} for agent {agent.get('id')}")
        return True
    return False


def process_session_file(path: Path, agents: dict[str, dict], active_sessions: set[str] = None) -> None:
    """Process an OpenCode session file and orient if needed.
    
    Only orients if the session is currently active (in the API).
    """
    session = load_opencode_session(path)
    if not session:
        return
    
    session_id = session.get("id", "")
    if not session_id:
        return
    
    if session_id in ORIENTED_SESSIONS:
        return  # Already oriented
    
    # Check if session is active (only fetch once if not provided)
    if active_sessions is None:
        active_sessions = get_active_session_ids()
    
    if session_id not in active_sessions:
        log.debug(f"Session {session_id[:8]} not active, skipping orientation")
        return
    
    directory = session.get("directory", "")
    if not directory:
        return
    
    agent = find_agent_for_directory(directory, agents)
    if agent:
        orient_session(session_id, agent)


def format_notification(msg: dict, to_agent_id: str) -> str:
    """Format agent-hub message with full response instructions."""
    from_agent = msg.get("from", "unknown")
    msg_type = msg.get("type", "message")
    content = msg.get("content", "")
    priority = msg.get("priority", "normal")
    thread_id = msg.get("threadId", "")

    # Type icons
    type_icons = {
        "question": "â“",
        "task": "ğŸ“‹",
        "context": "ğŸ“",
        "completion": "âœ…",
        "error": "âŒ",
    }
    icon = type_icons.get(msg_type, "ğŸ’¬")

    # Priority markers
    priority_markers = {
        "urgent": "ğŸš¨ URGENT",
        "high": "âš ï¸ HIGH",
        "normal": "",
        "low": "ğŸ’¤ LOW",
    }
    priority_str = priority_markers.get(priority, "")

    # Build notification block
    lines = [
        "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        f"â”‚ {icon} AGENT HUB MESSAGE",
        "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        f"â”‚ FROM: {from_agent}",
        f"â”‚ TYPE: {msg_type}" + (f" {priority_str}" if priority_str else ""),
    ]
    if thread_id:
        lines.append(f"â”‚ THREAD: {thread_id}")
    lines.extend([
        "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        f"â”‚ {content}",
        "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "â”‚ RESPOND using agent-hub_send_message:",
        f"â”‚   from: \"{to_agent_id}\"",
        f"â”‚   to: \"{from_agent}\"",
    ])
    if thread_id:
        lines.append(f"â”‚   threadId: \"{thread_id}\"")
    lines.extend([
        "â”‚   type: \"completion\" | \"context\" | \"question\" | \"error\"",
        "â”‚   content: <your response>",
        "â”‚",
        "â”‚ To resolve thread, include \"RESOLVED:\" in content.",
        "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
    ])

    return "\n".join(lines)


# =============================================================================
# Message Processing
# =============================================================================

def process_message_file(path: Path, agents: dict[str, dict]) -> None:
    """Process a new message file and inject if applicable."""
    try:
        msg = json.loads(path.read_text())
    except (json.JSONDecodeError, OSError) as e:
        log.warning(f"Failed to read message {path}: {e}")
        return

    # Ensure message has a threadId
    ensure_thread_id(msg, path)

    # Check if this message resolves a thread
    if check_thread_resolution(msg):
        return  # Thread resolved, messages archived

    # Determine target agent(s)
    to = msg.get("to", "")
    if to == "all":
        target_agents = list(agents.values())
    elif to in agents:
        target_agents = [agents[to]]
    else:
        log.debug(f"Unknown target agent: {to}")
        return

    # Skip if already read
    if msg.get("read"):
        return

    sessions = get_sessions()
    if not sessions:
        log.debug("No active sessions")
        return

    for agent in target_agents:
        # Don't notify sender
        if agent["id"] == msg.get("from"):
            continue

        matching_sessions = find_sessions_for_agent(agent, sessions)
        if matching_sessions:
            notification = format_notification(msg, agent["id"])
            for session in matching_sessions:
                inject_message(session["id"], notification)
            log.debug(f"Notified {len(matching_sessions)} session(s) for agent {agent['id']}")
        else:
            log.debug(f"No session found for agent {agent['id']}")


# =============================================================================
# Event Handler
# =============================================================================

class MessageHandler(FileSystemEventHandler):
    """Handle new message files in ~/.agent-hub/messages/."""

    def __init__(self, agents: dict[str, dict]):
        self.agents = agents

    def on_created(self, event: FileCreatedEvent) -> None:
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix != ".json":
            return
        # Ignore archive directory
        if "archive" in path.parts:
            return

        log.debug(f"New message file: {path.name}")
        # Small delay to ensure file is fully written
        time.sleep(0.1)
        process_message_file(path, self.agents)


class SessionHandler(FileSystemEventHandler):
    """Handle new/modified OpenCode session files for orientation."""

    def __init__(self, agents: dict[str, dict]):
        self.agents = agents

    def on_created(self, event: FileCreatedEvent) -> None:
        self._handle_session_event(event)

    def on_modified(self, event) -> None:
        self._handle_session_event(event)

    def _handle_session_event(self, event) -> None:
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix != ".json":
            return
        if not path.name.startswith("ses_"):
            return

        log.debug(f"Session file event: {path.name}")
        time.sleep(0.1)
        process_session_file(path, self.agents)


class AgentHandler(FileSystemEventHandler):
    """Handle agent registration changes to reload agents dict."""

    def __init__(self, agents: dict[str, dict]):
        self.agents = agents

    def on_created(self, event: FileCreatedEvent) -> None:
        self._reload()

    def on_modified(self, event) -> None:
        self._reload()

    def on_deleted(self, event) -> None:
        self._reload()

    def _reload(self) -> None:
        """Reload agents from disk."""
        new_agents = load_agents()
        self.agents.clear()
        self.agents.update(new_agents)
        log.debug(f"Reloaded agents: {list(self.agents.keys())}")


# =============================================================================
# Main
# =============================================================================

def main():
    # Ensure directories exist
    MESSAGES_DIR.mkdir(parents=True, exist_ok=True)
    ARCHIVE_DIR.mkdir(parents=True, exist_ok=True)
    THREADS_DIR.mkdir(parents=True, exist_ok=True)
    AGENTS_DIR.mkdir(parents=True, exist_ok=True)

    log.info(f"Watching messages: {MESSAGES_DIR}")
    log.info(f"Watching sessions: {OPENCODE_SESSIONS_DIR}")
    log.info(f"Watching agents: {AGENTS_DIR}")
    log.info(f"OpenCode API: {OPENCODE_URL}")
    log.info("All messages wake agents with response instructions")
    log.info(f"Message TTL: {MESSAGE_TTL_SECONDS}s, GC interval: {GC_INTERVAL_SECONDS}s")

    # Start hub server if not already running
    start_hub_server()

    # Shared agents dict - updated by AgentHandler
    agents = load_agents()
    log.info(f"Loaded {len(agents)} registered agents: {list(agents.keys())}")

    # Set up observers
    observer = Observer()

    # Watch messages directory
    message_handler = MessageHandler(agents)
    observer.schedule(message_handler, str(MESSAGES_DIR), recursive=False)

    # Watch OpenCode sessions directory (if exists)
    if OPENCODE_SESSIONS_DIR.exists():
        session_handler = SessionHandler(agents)
        observer.schedule(session_handler, str(OPENCODE_SESSIONS_DIR), recursive=False)
        # Process only currently active sessions on startup
        active_sessions = get_active_session_ids()
        if active_sessions:
            log.info(f"Found {len(active_sessions)} active sessions")
            for session_file in OPENCODE_SESSIONS_DIR.glob("ses_*.json"):
                process_session_file(session_file, agents, active_sessions)
    else:
        log.warning(f"Sessions directory not found: {OPENCODE_SESSIONS_DIR}")

    # Watch agents directory for registration changes
    agent_handler = AgentHandler(agents)
    observer.schedule(agent_handler, str(AGENTS_DIR), recursive=False)

    observer.start()

    # Handle signals for graceful shutdown
    def shutdown_handler(signum, frame):
        log.info(f"Received signal {signum}, shutting down...")
        observer.stop()
        stop_hub_server()
    
    signal.signal(signal.SIGTERM, shutdown_handler)
    signal.signal(signal.SIGINT, shutdown_handler)

    last_gc = time.time()
    try:
        while True:
            time.sleep(1)
            # Run GC periodically
            if time.time() - last_gc > GC_INTERVAL_SECONDS:
                run_gc(agents)
                last_gc = time.time()
            # Check if hub server is still running (restart if we started it and it died)
            if HUB_SERVER_PROCESS is not None and HUB_SERVER_PROCESS.poll() is not None:
                log.warning("Hub server died, restarting...")
                start_hub_server()
    except KeyboardInterrupt:
        log.info("Shutting down")
    finally:
        observer.stop()
        stop_hub_server()
    observer.join()


if __name__ == "__main__":
    main()
